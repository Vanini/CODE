1.城市美化（city.pas/c/cpp)
【题目描述】
城市A需要美化市容市貌，现在有n个楼房排成一列，每个楼房的高hi都在[1,1000]的范围内。市长请了一批工程师来对其中一些楼房进行修建，使楼房高度得到上升（不能让楼房高度下降），对一栋楼房修建，使其高度上升x，需要x^2的费用。
当所有修建完成后，我们把相邻两楼高度差的绝对值乘以c(0<=c<=1000)，得到的就是城市损失的钱，我们把它同样看作是费用。现在想请你合理安排修建楼房的方案，使得所需费用最小。
【输入格式】
第一行两个数n和c。
接下来n行，每行一个数，表示每栋楼的高度。
【输出格式】
仅一行一个数，表示最小所需的费用。
【样例输入】
5 5
2
2
1
6
8
【样例输出】
31
【数据规模】
对于10%数据， n <= 30, hi <= 50
对于30%数据， n <= 3500, hi <= 100
对于60%数据, n <= 50000, hi <= 100
对于80%数据, n <= 100000, hi <= 1000
对于100%数据, n <= 1000000, hi <= 1000
【hint】
请自觉使用int64保存相关变量以防止越界
【时限】
2s

2.邪恶的猴子（monkey.pas/c/cpp)
【题目描述】
你是一个在丛林中追逐猴子的猎人，你想用枪把猴子射下来。猴子藏在某棵树上，你是看不到它的。你可以向某棵树射击，若猴子在这棵树上它就完蛋了。若猴子不在，它就可以趁你装弹药的时候移动到某棵相邻的树上，而你无法发现它已转移。它一定不会在你射击之后停留在树上不动。你想要找到一种不管猴子的起始位置和跳法如何都一定可以杀死猴子的策略。请找出射击次数最少的方法。
举个例子，如果只有两棵相邻的树。你对着同一棵树射击两次就一定可以杀死猴子。如果人品好，第一次就可以杀死猴子。否则，第一次射击之后，猴子就一定会跳到第一次被射击的树上。第二次对着那棵树射击就可以杀死猴子了。
然而，丛林的复杂让你不一定可以获得胜利。一个例子就是有三棵树，互相连接。不管你打那一棵树，猴子总有两个地方可以跳（最坏情况是猴子可以预知你的下一个目标）。
【输入格式】
第一行包含两个整数n和m。n表示树的棵数，m代表树之间的关系数。
接下来m行，每行包含两个0到n-1之间的整数表示这两棵树是相邻的。每一对关系不会出现两次，没有树和自己连通，整个树林是连通的。
【输出格式】
如果打不死猴子输出“Impossible”。否则，请输出射击次数最少的方案。格式为L：V1,V2…VL。L代表射击次数，V1,V2…VL是每次射击的位置，用空格隔开。（注意冒号后面的空格）
如果有多组最优解，请输出字典序最小的。
【样例输入1】
2 1
0 1
【样例输出1】
2: 0 0
【样例输入2】
3 3
0 1
1 2
2 0
【样例输出2】
Impossible
【样例输入3】
4 3
0 1
2 3
1 3
【样例输出3】
4: 1 3 3 1
【数据规模】
对于30%数据, n <= 10
对于60%数据，n <= 15
对于100%数据，n <= 21
【时限】
1s

3.最小生成树(mst.pas/c/cpp)
【题目描述】 
有n个城市(编号从0..n-1)，m条公路(双向的)，从中选择n-1条边，使得任意的两个城市能够连通，一条边需要的c的费用和t的时间，定义一个方案的权值v=n-1条边的费用和*n-1条边的时间和，你的任务是求一个方案使得v最小
【输入格式】
第一行两个整数n,m,接下来每行四个整数a,b,c,t,表示有一条公路从城市a到城市b需要t时间和费用c
【输出格式】
仅一行两个整数sumc，sumt,（sumc表示使得v最小时的费用和，sumc表示最小的时间和） 如果存在多个解使得sumc*sumt相等，输出sumc最小的
【样例输入】
5 7
0 1 161 79
0 2 161 15
0 3 13 153
1 4 142 183
2 4 236 80
3 4 40 241
2 1 65 92
【样例输出】
279 501
【数据规模】
1<=N<=200
1<=m<=10000
0<=a,b<=n-1
0<=t,c<=255
有10%的数据m=n-1
有40%的数据有t=c
对于100%的数据如上所述
【时限】
10s
